Project members
    R-E Miller 
    Elliot Swan 
    Matthew Hill

Communication plan
    Communication will happen through a combination on in person meetings at the library and online meetings held through discord.
    The code will be shared through github so everyteam member can acesses the code

Tasks Involved/Team members assigned for each task and time to complete
        Side Note - Keep track of time as an actual completion time is submitted at the end of the project
    Server Tasks -  Matt Hill
      - Create server, verify names, handle multiple connections, gracefully shutdown
    Client Tasks - R-E Miller
      - Connect to server, decide on name, send and receive messages, disconnect
    Shared Tasks/curses integration - Elliot Swan
      - encode/decode JSON packets, Send/receive JSON packets, research and design UI in curses 

Programming Language
    The Server, Client, and Library will all be written in Python

Project Requirements (scope):
  -A working client/server chatroom
  - Client Requirements
    - Clients can choose a nickname given that it isn't taken
    - Clients will have a clean user interface
    - Clients will have access to older messages if they ask to receive them (/logs?)
    - Clients will be able to seamlessly exit the program. Either with a command or ctrl-c
    - The following are optional
    - Clients can clear their messages using a designated command. (/clear?)
    - User lists for clients?
    - Direct Messages? Would be hard to track but interesting to add.
  - Server Requirements 
    - Server will be able to store a chat log in a text file
    - Server will be able to verify user nicknames against other user names. This must be non blocking
    - Server will be able to gracefully shut down, sending messages to clients before termination
    - Server will be able to handle receiving multiple messages at a time
    - Server will be able to handle a maximum of people of 10 for the time being
    - The following are optional: 
    - The server operator may be able to act as a moderator?

Application Inputs and Outputs:
  Client program user inputs:
    - Client program should be able to get input through the curses module.
      - Provided the curses module works as intended, There will be an area where
        the user will be able to type any inputs into a text box. The user can escape this using 
        escape. The user could then bring up a user list or a manual. Direct messages could be interesting.
      - Commands can be executed through the syntax /command (This will cause certain combinations to be untypable on their own) 
        or through key combination (ctrl-C)
    - Client program outputs to the user:
      - The client program will output a user interface by use of the curses module
      - There will be a space for user input at the bottom of the screen 
      - Above space for messages to be typed, there will be space for messages from other users
        to be displayed
      
    - Server program user inputs:
      - Provided we do decided to make it a moderator type thing
      - there will be a command to print user nicknames
      - command to disconnect users
    - Server program outputs to user:
      - The server should output whenever there is a connect or disconnect
      - The server maybe should print that it is broadcasting a message

List of functionalities that will be common to both client and server
    Both will need functions for sending and receiving messages that will need to be encoded and decoded on either send or receive respectively. 
    The server and client will need message formatting to display the messages.
    Both will need an Authentication method for username and personal in the chat 

Application Protocol:
  -The lynchpin of the communication will come from JSON packets.
    -JSON Packets use:
      - NICK: the nickname 
      - MSG: The message
  -Client to server
    - On  connect the client will wait for a connect confirmation message from the server. It then enters the nickname confirmation loop.
    - On connect NICK is None (Requires testing)
    - NICK will not be set until approved by the server. 
    - Connect MSG  will always be the name the user selects until it is approved
    - Basic client server interaction will be a JSON packet structured as above.
    - If the client receives a packet of it's own nickname it will be used as a 
      verification that it's own message was sent.
    - Otherwise it will print the nickname from the sender followed by the MSG.
    - If the MSG is /exit the client will terminate
  -Server to client
    - On connect the server will send a message to the client.
    - The server will verify the user's nickname 
    - In basic operation, the server will receive a JSON packet and then simply push it to every single user.
    - If a user sends a packet that contains /exit it will terminate that connection and remove the nickname from the list of nicknames

Testing:
|Test Case|Brief|Input|Expected Output|
|---|---|---|---|
|1|Successful Login|myUser|Successful Connection to chatroom|
|2|Invalid Login|None (Reserved or duplicate name)|Retry Username|
|3|Receive Message|Hello World|Every user receives the message packet "Hello World"|
|4|Send Messages|Hello World|Server receives the message packet "Hello World"|
|5|Joining late/retrieve logs|\logs|Should a user type a command, it will retrieve logs|
|6|Invalid Command|\notcmd|If a user types a command(\command) incorrectly, the program will show an error message|
|7|User input Will not be lost on message receive|None|Clean UI as described before|

