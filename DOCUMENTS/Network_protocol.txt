Network Socket Specifications:
  The program will utilize json packets in order to send and receive information in a concise manner.
  A packet will have the two following parts:
    - a 2 byte length, sent in big endian, specifying the length of the following JSON packet. This is done to ensure that the entire packet is read.
    - a JSON packet. It has the following three fields:
      - 'msg' - The incoming message if there is one. Used to communicate in certain points that will be described in the chat protocol.
      - 'nick' - The nickname of the person who sent the message. Set to None upon connection, and will change upon approval. server has reserved nickname SERVER
      - 'proto' - The protocol that will be followed. Used to communicate where each connection is sending its messaage. The accepted protocols will be described below.

        - connect - This protocol is used by the server to communicate to the client that it acknowledges its connection. it also sends the msg 'HELLO'. 

        - verify - This protocol is used by the client to tell the server that it is in the verification step of submitting it's nickname.
          The msg at this stage is the nickname that the client would like to use. 

        - broadcast - This protocol is used by the client to tell the server that it would like to broadcast it's msg field to every other connected client.
          The server will then send the exact same packet to every other connected client. If a client receives broadcast as a proto, it will simply print the nick and msg fields.

        - goodbye - This protocol is used by the client to tell the server that it is about to disconnect. The server will then handle resource cleanup 
          (nickname removal, removal from socket lists) and close the socket. 

        - shutdown - This protocol is used by the server to tell connected clients that it is about to shut down. The msg field will 
          contain a message saying how long until shutdown each client has. 

The overall chat protocol will be easier to understand from an implementation point of view by breaking it into two halves, client half and server half.
Chat Protocol Specifications (client side):
  The client begins by opening a socket upon the information supplied in the command line. It will then connect to the server using the information from the command line.
  Upon connection, the client will receive a packet from the server. This packet may be broken down to receive the msg = 'HELLO' and proto = 'connect'.
  Now begins the nickname verification loop:
    The user will be prompted to decide on a unique name the client will use for the chat room.
    When the user inputs a name, the client will send a packet to the server with the proto 'verify', and the msg field containing the name the user would like to use. 
      #NOTE: WE HAVE TO CHANGE THIS IN THE SERVER, the proto is wrong but I dont want to cause issues right now, there shouldnt be one i dont think though. 
      - if the user's nickname is accepted by the server, the client will receive a packet with msg 'READY' and proto 'ready'
      #NOTE: again, the proto is off in the real code.
      - if the user's nickname is not accepted by the server, the client will receive a packet with msg 'RETRY' and proto 'retry'. If this happens the loop will restart and prompt for another name. 
    Once the client has created an accepted nickname, it will move on to the next part of the chat, the actual chatroom.
    While in the chatroom, the user must prompt for input from the user while also checking a socket for packets. (This can be done in a variety of ways, we used select and threading)
    To send a message: 
      The user will be prompted for an input. When input by the user, it will be packed into a json packet in the field msg, along with the user's nickname in field nick and proto
      field 'broadcast'. the length of this in bytes will be appended to the front of the packet and then sent to the server. This message will then be broadcast back to 
      every other connection in the server, including the client that sent it. It is the client's job to ignore messages from itself if it does not want to print the information 
      it sent again. 
    To receive a message: 
      The user will receive messages by reading the 2 bytes as mentioned in the network protocol, then it will receive a json packet of length decided by the two bytes. The 
      information may then be unpacked from the dictionary returned in the fields nick, msg, and proto. The only protocols supported are broadcast, which means that another user or 
      the server sent the message and it is to be printed, or shutdown, meaning that the server intends to shut down and is giving a warning to the client. There is also the goodbye
      protocol, which is announcement made by the server to indicate a disconnect from another client. 
    To exit the client:
      The user may press control-c to exit the client, at which point the client will send a message to the server with the msg 'BYE' and proto 'goodbye', to signal to the 
      server that it intends to close it's connection. At this point the client may close it's socket connection and handle any remaining cleanup, then exit. 

  Server Protocol Specifications:
    The server beings by opening a socket upon the information supplied by the command line. It will then bind to that information, and begin listening for any connections.
    It must decide on a form of asynchronous I/O, in this case we have decided that the select library is well suited to out needs so it will be focused on that. 
    Select will be used to poll the sockets for input, in the case there is an input, it will be read and the protocol field will be used to guide the server 
    into performing the correct tasks. 
    If the original socket may be read from and it is a first time connection, begin by accepting the connection, and adding any connection information to a dictionary to store it,
    as well as add the socket to the list of sockets to be polled for input. In this same step, send a message to the client with the nick 'SERVER', msg 'HELLO', and 
    proto 'connect'. At this point the server may begin handling any other inputs it may have. 
    If the socket being read from is a socket created by accept, Then the server will read and handle it based on whatever is held inside the proto field. Below are the actions the server 
    must take if it receives a packet containing the protocols:

      #NOTE: THIS IS DIFFERENT IN CODE, PLEASE CHANGE
      verify - The client is attempting to verify their name. Within the msg field is the name the user would like to use. 
        if the msg field is an already in use nickname, send a packet with msg 'RETRY' and proto 'retry'. The server is done with this step, and may continue with i/o handling. 
        if the msg field is a unique nickname, send a packet with msg 'READY' and proto 'ready'. The server will append the nickname to the list of inuse nicknames and log the 
          information that is required of it. The server may then continue with i/o.
      broadcast - The client sent a message they would like to broadcast. Recreate the packet and send to every connection the server has open. No changes have to be made. 
      Log the packet. The server may continue with i/o.
      goodbye - The client is attempting to disconnect. First, broadcast to every member of the server that the nickname that was read is going to disconnect, broadcast with nickname 
      SERVER and protocol 'goodbye'. The connection and nickname associated with that client will be removed from the list of in use connections and nicknames respectively, and the
      socket will be closed. The server may now continue with i/o.
      In the case that a packet is not read, and a terminated socket is received, there was an error sending from the client or the client shutdown unexpectedly. In this case,
      there should be a dictionary mapping connection to nickname. Remove the connection and nickname respectively, and close the socket. The server may now continue with i/o. 
